#!/usr/bin/make

#-------------------------------------------------------------------------------
#
# Makefile for building the images.
#
#-------------------------------------------------------------------------------

# Add supported docker build flags, if specified.
build_opts=
ifneq (${NOCACHE}, )
	build_opts=--no-cache
endif

# Specify the build argument to set a commit hash.
commit_hash_opt=
commit_hash=$(shell sh -c "git rev-parse --short HEAD")
ifneq ($(commit_hash), )
	ifneq (${COMMIT_HASH}, )
		commit_hash=${COMMIT_HASH}
	endif
	commit_hash_opt=--build-arg COMMIT_HASH=$(shell sh -c "git rev-parse --short HEAD")
endif

# Print out help text.
help:
	@echo ""
	@echo "Make targets:"
	@echo "    build"
	@echo "    push"
	@echo ""

# Build the container image.
#
# The image tag is generated by parsing the Dockerfile for specific ARG
# parameters. Optionally, environment variables or makefile parameters for
# REGISTRY and ORGANIZATION can be used to override those set in the Dockerfile.
#
# For example:
#     make REGISTRY=foo.com ORGANIZATION=bar java-jdk
#     export REGISTRY=foo.com; make java-jdk
#
package:
	@echo "Building image"
	$(eval REG=$(shell sh -c "(test ${REGISTRY} && echo ${REGISTRY}) || grep '^ARG REGISTRY' container/Dockerfile | cut -d= -f2"))
	$(eval REG=$(shell sh -c "(test $(REG) && echo $(REG)/)"))
	$(eval ORG=$(shell sh -c "(test ${ORGANIZATION} && echo ${ORGANIZATION}) || grep '^ARG ORGANIZATION' container/Dockerfile | cut -d= -f2"))
	$(eval NAME=$(shell sh -c "grep '^ARG APP_NAME' container/Dockerfile | cut -d= -f2"))
	$(eval VERS=$(shell sh -c "grep '^ARG APP_VERSION' container/Dockerfile | cut -d= -f2"))
	$(eval BUILD=$(shell sh -c "grep '^ARG APP_BUILD_NUMBER' container/Dockerfile | cut -d= -f2"))
	$(eval TAG="$(REG)$(ORG)/$(NAME):$(VERS)-$(BUILD)")
	@cd container && docker build $(build_opts) $(commit_hash_opt) -t $(TAG) .

build:
	@cd service && mvn package